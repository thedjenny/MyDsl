/*
 * generated by Xtext 2.29.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.Component;
import org.xtext.example.mydsl.myDsl.ExportModel;
import org.xtext.example.mydsl.myDsl.Layer;
import org.xtext.example.mydsl.myDsl.Link;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.NetlistType;
import org.xtext.example.mydsl.myDsl.Node;
import org.xtext.example.mydsl.myDsl.Nodes;
import org.xtext.example.mydsl.myDsl.Tag;
import org.xtext.example.mydsl.myDsl.Variable;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case MyDslPackage.EXPORT_MODEL:
				sequence_ExportModel(context, (ExportModel) semanticObject); 
				return; 
			case MyDslPackage.LAYER:
				sequence_Layer(context, (Layer) semanticObject); 
				return; 
			case MyDslPackage.LINK:
				sequence_Link(context, (Link) semanticObject); 
				return; 
			case MyDslPackage.NETLIST_TYPE:
				sequence_NetlistType(context, (NetlistType) semanticObject); 
				return; 
			case MyDslPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case MyDslPackage.NODES:
				sequence_Nodes(context, (Nodes) semanticObject); 
				return; 
			case MyDslPackage.TAG:
				sequence_Tag(context, (Tag) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (compoId=STRING compoIda=STRING compoIdf=STRING compoIdt=STRING vars+=Variable*)
	 * </pre>
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExportModel returns ExportModel
	 *
	 * Constraint:
	 *     export=NetlistType
	 * </pre>
	 */
	protected void sequence_ExportModel(ISerializationContext context, ExportModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPORT_MODEL__EXPORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPORT_MODEL__EXPORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExportModelAccess().getExportNetlistTypeParserRuleCall_1_0(), semanticObject.getExport());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Layer returns Layer
	 *
	 * Constraint:
	 *     (coucheName=STRING components+=Component*)
	 * </pre>
	 */
	protected void sequence_Layer(ISerializationContext context, Layer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Link returns Link
	 *
	 * Constraint:
	 *     (CompID=STRING portID=STRING portName=STRING portName2=STRING baliseFermante=Balise)
	 * </pre>
	 */
	protected void sequence_Link(ISerializationContext context, Link semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LINK__COMP_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LINK__COMP_ID));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LINK__PORT_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LINK__PORT_ID));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LINK__PORT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LINK__PORT_NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LINK__PORT_NAME2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LINK__PORT_NAME2));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LINK__BALISE_FERMANTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LINK__BALISE_FERMANTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLinkAccess().getCompIDSTRINGTerminalRuleCall_1_0(), semanticObject.getCompID());
		feeder.accept(grammarAccess.getLinkAccess().getPortIDSTRINGTerminalRuleCall_3_0(), semanticObject.getPortID());
		feeder.accept(grammarAccess.getLinkAccess().getPortNameSTRINGTerminalRuleCall_5_0(), semanticObject.getPortName());
		feeder.accept(grammarAccess.getLinkAccess().getPortName2STRINGTerminalRuleCall_7_0(), semanticObject.getPortName2());
		feeder.accept(grammarAccess.getLinkAccess().getBaliseFermanteBaliseParserRuleCall_8_0(), semanticObject.getBaliseFermante());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NetlistType returns NetlistType
	 *
	 * Constraint:
	 *     (docname=STRING doctype=STRING? layer+=Layer* nodes=Nodes)
	 * </pre>
	 */
	protected void sequence_NetlistType(ISerializationContext context, NetlistType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (nodeName=STRING links+=Link*)
	 * </pre>
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Nodes returns Nodes
	 *
	 * Constraint:
	 *     nodes+=Node+
	 * </pre>
	 */
	protected void sequence_Nodes(ISerializationContext context, Nodes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Tag returns Tag
	 *
	 * Constraint:
	 *     (tagNum=INT tagName=STRING var=ID? tagNum=INT)
	 * </pre>
	 */
	protected void sequence_Tag(ISerializationContext context, Tag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (varName=STRING tags+=Tag*)
	 * </pre>
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
